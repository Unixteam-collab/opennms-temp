reports=jvmClassLoading.jvmClassesLoadedCount, \
jvmClassLoading.jvmClassesTotalLoadedCount, \
jvmClassLoading.jvmClassesUnloadedCount, \
jvmMemory.jvmMemoryPendingFinalCount, \
jvmMemory.jvmMemoryHeapInitSize, \
jvmMemory.jvmMemoryHeapUsed, \
jvmMemory.jvmMemoryHeapCommitted, \
jvmMemory.jvmMemoryHeapMaxSize, \
jvmMemory.jvmMemoryNonHeapInitSize, \
jvmMemory.jvmMemoryNonHeapUsed, \
jvmMemory.jvmMemoryNonHeapCommitted, \
jvmMemory.jvmMemoryNonHeapMaxSize, \
jvmMemGCTable.jvmMemGCCount, \
jvmMemGCTable.jvmMemGCTimeMs, \
jvmMemPoolTable.jvmMemPoolPeakReset, \
jvmMemPoolTable.jvmMemPoolInitSize, \
jvmMemPoolTable.jvmMemPoolUsed, \
jvmMemPoolTable.jvmMemPoolCommitted, \
jvmMemPoolTable.jvmMemPoolMaxSize, \
jvmMemPoolTable.jvmMemPoolPeakUsed, \
jvmMemPoolTable.jvmMemPoolPeakCommitted, \
jvmMemPoolTable.jvmMemPoolPeakMaxSize, \
jvmMemPoolTable.jvmMemPoolCollectUsed, \
jvmMemPoolTable.jvmMemPoolCollectCommitted, \
jvmMemPoolTable.jvmMemPoolCollectMaxSize, \
jvmMemPoolTable.jvmMemPoolThreshold, \
jvmMemPoolTable.jvmMemPoolThreshdCount, \
jvmMemPoolTable.jvmMemPoolCollectThreshold, \
jvmMemPoolTable.jvmMemPoolCollectThreshdCount, \
jvmThreading.jvmThreadCount, \
jvmThreading.jvmThreadDaemonCount, \
jvmThreading.jvmThreadPeakCount, \
jvmThreading.jvmThreadTotalStartedCount, \
jvmThreading.jvmThreadPeakCountReset, \
jvmThreadInstanceTable.jvmThreadInstId, \
jvmThreadInstanceTable.jvmThreadInstBlockCount, \
jvmThreadInstanceTable.jvmThreadInstBlockTimeMs, \
jvmThreadInstanceTable.jvmThreadInstWaitCount, \
jvmThreadInstanceTable.jvmThreadInstWaitTimeMs, \
jvmThreadInstanceTable.jvmThreadInstCpuTimeNs, \
jvmRuntime.jvmRTInputArgsCount, \
jvmRuntime.jvmRTUptimeMs, \
jvmRuntime.jvmRTStartTimeMs, \
jvmCompilation.jvmJITCompilerTimeMs, \
jvmOS.jvmOSProcessorCount

report.jvmClassLoading.jvmClassesLoadedCount.name=JVM-MANAGEMENT-MIB::jvmClassLoading::jvmClassesLoadedCount
report.jvmClassLoading.jvmClassesLoadedCount.columns=jvmClassLoadedCount
report.jvmClassLoading.jvmClassesLoadedCount.type=nodeSnmp
report.jvmClassLoading.jvmClassesLoadedCount.description=The number of classes currently loaded in the JVM. See java.lang.management.ClassLoadingMXBean.getLoadedClassCount() 
report.jvmClassLoading.jvmClassesLoadedCount.command=--title="JVM-MANAGEMENT-MIB::jvmClassLoading::jvmClassesLoadedCount" \
 DEF:var={rrd1}:jvmClassLoadedCount:AVERAGE \
 LINE1:var#00ccff:"jvmClassesLoadedCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmClassLoading.jvmClassesTotalLoadedCount.name=JVM-MANAGEMENT-MIB::jvmClassLoading::jvmClassesTotalLoadedCount
report.jvmClassLoading.jvmClassesTotalLoadedCount.columns=jvmClasTotaLoadCoun
report.jvmClassLoading.jvmClassesTotalLoadedCount.type=nodeSnmp
report.jvmClassLoading.jvmClassesTotalLoadedCount.description=The total number of classes that have been loaded since the JVM has started execution. See java.lang.management.ClassLoadingMXBean. getTotalLoadedClassCount() 
report.jvmClassLoading.jvmClassesTotalLoadedCount.command=--title="JVM-MANAGEMENT-MIB::jvmClassLoading::jvmClassesTotalLoadedCount" \
 DEF:var={rrd1}:jvmClasTotaLoadCoun:AVERAGE \
 LINE1:var#00ccff:"jvmClassesTotalLoadedCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmClassLoading.jvmClassesUnloadedCount.name=JVM-MANAGEMENT-MIB::jvmClassLoading::jvmClassesUnloadedCount
report.jvmClassLoading.jvmClassesUnloadedCount.columns=jvmClassUnloadCount
report.jvmClassLoading.jvmClassesUnloadedCount.type=nodeSnmp
report.jvmClassLoading.jvmClassesUnloadedCount.description=The total number of classes that have been unloaded since the JVM has started execution. See java.lang.management.ClassLoadingMXBean.getUnloadedClassCount() 
report.jvmClassLoading.jvmClassesUnloadedCount.command=--title="JVM-MANAGEMENT-MIB::jvmClassLoading::jvmClassesUnloadedCount" \
 DEF:var={rrd1}:jvmClassUnloadCount:AVERAGE \
 LINE1:var#00ccff:"jvmClassesUnloadedCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryPendingFinalCount.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryPendingFinalCount
report.jvmMemory.jvmMemoryPendingFinalCount.columns=jvmMemoPendFinaCoun
report.jvmMemory.jvmMemoryPendingFinalCount.type=nodeSnmp
report.jvmMemory.jvmMemoryPendingFinalCount.description=The approximate number objects that are pending for finalization. See java.lang.management.MemoryMXBean. getObjectPendingFinalizationCount() 
report.jvmMemory.jvmMemoryPendingFinalCount.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryPendingFinalCount" \
 DEF:var={rrd1}:jvmMemoPendFinaCoun:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryPendingFinalCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryHeapInitSize.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapInitSize
report.jvmMemory.jvmMemoryHeapInitSize.columns=jvmMemoHeapInitSize
report.jvmMemory.jvmMemoryHeapInitSize.type=nodeSnmp
report.jvmMemory.jvmMemoryHeapInitSize.description= Total amount of memory (in bytes) that the Java virtual machine initially requests from the operating system for memory management for heap memory pools. See java.lang.management.MemoryMXBean.getHeapMemoryUsage().getInit() 
report.jvmMemory.jvmMemoryHeapInitSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapInitSize" \
 DEF:var={rrd1}:jvmMemoHeapInitSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryHeapInitSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryHeapUsed.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapUsed
report.jvmMemory.jvmMemoryHeapUsed.columns=jvmMemoryHeapUsed
report.jvmMemory.jvmMemoryHeapUsed.type=nodeSnmp
report.jvmMemory.jvmMemoryHeapUsed.description= Total amount of used memory (in bytes) from heap memory pools. See java.lang.management.MemoryMXBean.getHeapMemoryUsage().getUsed() 
report.jvmMemory.jvmMemoryHeapUsed.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapUsed" \
 DEF:var={rrd1}:jvmMemoryHeapUsed:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryHeapUsed" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryHeapCommitted.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapCommitted
report.jvmMemory.jvmMemoryHeapCommitted.columns=jvmMemoryHeapCommit
report.jvmMemory.jvmMemoryHeapCommitted.type=nodeSnmp
report.jvmMemory.jvmMemoryHeapCommitted.description= Total amount of memory (in bytes) committed by heap memory pools. See java.lang.management.MemoryMXBean.getHeapMemoryUsage(). getCommitted() 
report.jvmMemory.jvmMemoryHeapCommitted.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapCommitted" \
 DEF:var={rrd1}:jvmMemoryHeapCommit:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryHeapCommitted" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryHeapMaxSize.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapMaxSize
report.jvmMemory.jvmMemoryHeapMaxSize.columns=jvmMemorHeapMaxSize
report.jvmMemory.jvmMemoryHeapMaxSize.type=nodeSnmp
report.jvmMemory.jvmMemoryHeapMaxSize.description= Total maximum size of memory (in bytes) for all heap memory pools. See java.lang.management.MemoryMXBean.getHeapMemoryUsage().getMax() 
report.jvmMemory.jvmMemoryHeapMaxSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryHeapMaxSize" \
 DEF:var={rrd1}:jvmMemorHeapMaxSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryHeapMaxSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryNonHeapInitSize.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapInitSize
report.jvmMemory.jvmMemoryNonHeapInitSize.columns=jvmMemNonHeaIniSize
report.jvmMemory.jvmMemoryNonHeapInitSize.type=nodeSnmp
report.jvmMemory.jvmMemoryNonHeapInitSize.description= Total amount of memory (in bytes) that the Java virtual machine initially requests from the operating system for memory management for non heap memory pools. See java.lang.management.MemoryMXBean.getNonHeapMemoryUsage().getInit() 
report.jvmMemory.jvmMemoryNonHeapInitSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapInitSize" \
 DEF:var={rrd1}:jvmMemNonHeaIniSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryNonHeapInitSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryNonHeapUsed.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapUsed
report.jvmMemory.jvmMemoryNonHeapUsed.columns=jvmMemorNonHeapUsed
report.jvmMemory.jvmMemoryNonHeapUsed.type=nodeSnmp
report.jvmMemory.jvmMemoryNonHeapUsed.description= Total amount of used memory (in bytes) from non heap memory pools. See java.lang.management.MemoryMXBean.getNonHeapMemoryUsage().getUsed() 
report.jvmMemory.jvmMemoryNonHeapUsed.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapUsed" \
 DEF:var={rrd1}:jvmMemorNonHeapUsed:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryNonHeapUsed" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryNonHeapCommitted.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapCommitted
report.jvmMemory.jvmMemoryNonHeapCommitted.columns=jvmMemoNonHeapCommi
report.jvmMemory.jvmMemoryNonHeapCommitted.type=nodeSnmp
report.jvmMemory.jvmMemoryNonHeapCommitted.description= Total amount of memory (in bytes) committed by non heap memory pools. See java.lang.management.MemoryMXBean. getNonHeapMemoryUsage().getCommitted() 
report.jvmMemory.jvmMemoryNonHeapCommitted.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapCommitted" \
 DEF:var={rrd1}:jvmMemoNonHeapCommi:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryNonHeapCommitted" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemory.jvmMemoryNonHeapMaxSize.name=JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapMaxSize
report.jvmMemory.jvmMemoryNonHeapMaxSize.columns=jvmMemNonHeaMaxSize
report.jvmMemory.jvmMemoryNonHeapMaxSize.type=nodeSnmp
report.jvmMemory.jvmMemoryNonHeapMaxSize.description= Total maximum size of memory (in bytes) for all non heap memory pools. See java.lang.management.MemoryMXBean.getNonHeapMemoryUsage().getMax() 
report.jvmMemory.jvmMemoryNonHeapMaxSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemory::jvmMemoryNonHeapMaxSize" \
 DEF:var={rrd1}:jvmMemNonHeaMaxSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemoryNonHeapMaxSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemGCTable.jvmMemGCCount.name=JVM-MANAGEMENT-MIB::jvmMemGCTable::jvmMemGCCount
report.jvmMemGCTable.jvmMemGCCount.columns=jvmMemGCCount
report.jvmMemGCTable.jvmMemGCCount.type=jvmMemGCEntry
report.jvmMemGCTable.jvmMemGCCount.description=The total number of collections that have occurred, as returned by GarbageCollectorMXBean.getCollectionCount(). If garbage collection statistics are not available, this object is set to 0. See java.lang.management.GarbageCollectorMXBean.getCollectionCount() 
report.jvmMemGCTable.jvmMemGCCount.command=--title="JVM-MANAGEMENT-MIB::jvmMemGCTable::jvmMemGCCount" \
 DEF:var={rrd1}:jvmMemGCCount:AVERAGE \
 LINE1:var#00ccff:"jvmMemGCCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemGCTable.jvmMemGCTimeMs.name=JVM-MANAGEMENT-MIB::jvmMemGCTable::jvmMemGCTimeMs
report.jvmMemGCTable.jvmMemGCTimeMs.columns=jvmMemGCTimeMs
report.jvmMemGCTable.jvmMemGCTimeMs.type=jvmMemGCEntry
report.jvmMemGCTable.jvmMemGCTimeMs.description=The approximate accumulated collection elapsed time in milliseconds, since the Java virtual machine has started. This object is set to 0 if the collection elapsed time is undefined for this collector. See java.lang.management.GarbageCollectorMXBean.getCollectionTime() 
report.jvmMemGCTable.jvmMemGCTimeMs.command=--title="JVM-MANAGEMENT-MIB::jvmMemGCTable::jvmMemGCTimeMs" \
 DEF:var={rrd1}:jvmMemGCTimeMs:AVERAGE \
 LINE1:var#00ccff:"jvmMemGCTimeMs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolPeakReset.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakReset
report.jvmMemPoolTable.jvmMemPoolPeakReset.columns=jvmMemPoolPeakReset
report.jvmMemPoolTable.jvmMemPoolPeakReset.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolPeakReset.description= This object indicates the last time - in milliseconds - at which the peak memory usage statistic of this memory pool was reset to the current memory usage. This corresponds to a time stamp as returned by java.lang.System.currentTimeMillis(); Setting this object to a time earlier than its current time value has no effect. Setting this object to a time later than its current time value causes the peak memory usage statistic of this memory pool to be reset to the current memory usage. The new value of this object will be the time at which the reset operation is triggered. There could be a delay between the time at which the reset operation is triggered and the time at which the actual resetting happens, so this value is only indicative. See java.lang.management.MemoryPoolMXBean.resetPeakUsage() 
report.jvmMemPoolTable.jvmMemPoolPeakReset.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakReset" \
 DEF:var={rrd1}:jvmMemPoolPeakReset:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolPeakReset" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolInitSize.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolInitSize
report.jvmMemPoolTable.jvmMemPoolInitSize.columns=jvmMemPoolInitSize
report.jvmMemPoolTable.jvmMemPoolInitSize.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolInitSize.description= Initial size of this memory pool. See java.lang.management.MemoryPoolMXBean.getUsage().getInit() 
report.jvmMemPoolTable.jvmMemPoolInitSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolInitSize" \
 DEF:var={rrd1}:jvmMemPoolInitSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolInitSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolUsed.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolUsed
report.jvmMemPoolTable.jvmMemPoolUsed.columns=jvmMemPoolUsed
report.jvmMemPoolTable.jvmMemPoolUsed.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolUsed.description= Amount of used memory in this memory pool. See java.lang.management.MemoryPoolMXBean.getUsage().getUsed() 
report.jvmMemPoolTable.jvmMemPoolUsed.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolUsed" \
 DEF:var={rrd1}:jvmMemPoolUsed:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolUsed" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolCommitted.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCommitted
report.jvmMemPoolTable.jvmMemPoolCommitted.columns=jvmMemPoolCommitted
report.jvmMemPoolTable.jvmMemPoolCommitted.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolCommitted.description= Amount of committed memory in this memory pool. See java.lang.management.MemoryPoolMXBean.getUsage().getCommitted() 
report.jvmMemPoolTable.jvmMemPoolCommitted.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCommitted" \
 DEF:var={rrd1}:jvmMemPoolCommitted:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolCommitted" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolMaxSize.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolMaxSize
report.jvmMemPoolTable.jvmMemPoolMaxSize.columns=jvmMemPoolMaxSize
report.jvmMemPoolTable.jvmMemPoolMaxSize.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolMaxSize.description= Maximal size of this memory pool. See java.lang.management.MemoryPoolMXBean.getUsage().getMax() 
report.jvmMemPoolTable.jvmMemPoolMaxSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolMaxSize" \
 DEF:var={rrd1}:jvmMemPoolMaxSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolMaxSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolPeakUsed.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakUsed
report.jvmMemPoolTable.jvmMemPoolPeakUsed.columns=jvmMemPoolPeakUsed
report.jvmMemPoolTable.jvmMemPoolPeakUsed.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolPeakUsed.description= Amount of used memory in this memory pool when the peak usage was reached. See java.lang.management.MemoryPoolMXBean.getPeakUsage().getUsed() 
report.jvmMemPoolTable.jvmMemPoolPeakUsed.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakUsed" \
 DEF:var={rrd1}:jvmMemPoolPeakUsed:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolPeakUsed" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolPeakCommitted.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakCommitted
report.jvmMemPoolTable.jvmMemPoolPeakCommitted.columns=jvmMemPoolPeakCommi
report.jvmMemPoolTable.jvmMemPoolPeakCommitted.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolPeakCommitted.description= Amount of committed memory in this memory pool when the peak usage was reached. See java.lang.management.MemoryPoolMXBean.getPeakUsage().getCommitted() 
report.jvmMemPoolTable.jvmMemPoolPeakCommitted.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakCommitted" \
 DEF:var={rrd1}:jvmMemPoolPeakCommi:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolPeakCommitted" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolPeakMaxSize.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakMaxSize
report.jvmMemPoolTable.jvmMemPoolPeakMaxSize.columns=jvmMemPooPeaMaxSize
report.jvmMemPoolTable.jvmMemPoolPeakMaxSize.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolPeakMaxSize.description= Maximal size of this memory pool when the peak usage was reached. See java.lang.management.MemoryPoolMXBean.getPeakUsage().getMax() 
report.jvmMemPoolTable.jvmMemPoolPeakMaxSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolPeakMaxSize" \
 DEF:var={rrd1}:jvmMemPooPeaMaxSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolPeakMaxSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolCollectUsed.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectUsed
report.jvmMemPoolTable.jvmMemPoolCollectUsed.columns=jvmMemPoolColleUsed
report.jvmMemPoolTable.jvmMemPoolCollectUsed.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolCollectUsed.description= The amount of used memory at the most recent time that the Java virtual machine has expended effort in recycling unused objects in this memory pool. See java.lang.management.MemoryPoolMXBean.getCollectionUsage().getUsed() 
report.jvmMemPoolTable.jvmMemPoolCollectUsed.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectUsed" \
 DEF:var={rrd1}:jvmMemPoolColleUsed:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolCollectUsed" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolCollectCommitted.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectCommitted
report.jvmMemPoolTable.jvmMemPoolCollectCommitted.columns=jvmMemPoolCollCommi
report.jvmMemPoolTable.jvmMemPoolCollectCommitted.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolCollectCommitted.description= The amount of committed memory at the most recent time that the Java virtual machine has expended effort in recycling unused objects in this memory pool. See java.lang.management.MemoryPoolMXBean.getCollectionUsage(). getCommitted() 
report.jvmMemPoolTable.jvmMemPoolCollectCommitted.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectCommitted" \
 DEF:var={rrd1}:jvmMemPoolCollCommi:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolCollectCommitted" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolCollectMaxSize.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectMaxSize
report.jvmMemPoolTable.jvmMemPoolCollectMaxSize.columns=jvmMemPooColMaxSize
report.jvmMemPoolTable.jvmMemPoolCollectMaxSize.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolCollectMaxSize.description= The value of the maximum amount of memory at the most recent time that the Java virtual machine has expended effort in recycling unused objects in this memory pool. See java.lang.management.MemoryPoolMXBean.getCollectionUsage().getMax() 
report.jvmMemPoolTable.jvmMemPoolCollectMaxSize.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectMaxSize" \
 DEF:var={rrd1}:jvmMemPooColMaxSize:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolCollectMaxSize" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolThreshold.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolThreshold
report.jvmMemPoolTable.jvmMemPoolThreshold.columns=jvmMemPoolThreshold
report.jvmMemPoolTable.jvmMemPoolThreshold.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolThreshold.description=The threshold value for the memory usage of this memory pool, in bytes. A zero value (0) indicates that no threshold value is configured. When the amount of used memory crosses over this threshold value the JVM will trigger a usage memory threshold exceeded notification, and the jvmMemPoolThreshdCount increases. If memory usage threshold is not supported, then this object, if implemented, will always be equals to 0. In that case, attempting to set this object will trigger an inconsistentValue error. See also jvmMemPoolThreshdSupport. See java.lang.management.MemoryPoolMXBean.getUsageThreshold(), java.lang.management.MemoryPoolMXBean.setUsageThreshold(long), java.lang.management.MemoryPoolMXBean.getUsageThresholdCount(), java.lang.management.MemoryPoolMXBean.isUsageThresholdSupported() 
report.jvmMemPoolTable.jvmMemPoolThreshold.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolThreshold" \
 DEF:var={rrd1}:jvmMemPoolThreshold:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolThreshold" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolThreshdCount.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolThreshdCount
report.jvmMemPoolTable.jvmMemPoolThreshdCount.columns=jvmMemPoolThreCount
report.jvmMemPoolTable.jvmMemPoolThreshdCount.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolThreshdCount.description=The number of times that the memory usage has crossed the usage threshold, as detected by the Java virtual machine. If memory usage threshold is not supported, then this object, if implemented, will always be equals to 0. See also jvmMemPoolThresholdSupport. See java.lang.management.MemoryPoolMXBean.getUsageThresholdCount(), java.lang.management.MemoryPoolMXBean.isUsageThresholdSupported() 
report.jvmMemPoolTable.jvmMemPoolThreshdCount.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolThreshdCount" \
 DEF:var={rrd1}:jvmMemPoolThreCount:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolThreshdCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolCollectThreshold.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectThreshold
report.jvmMemPoolTable.jvmMemPoolCollectThreshold.columns=jvmMemPoolCollThres
report.jvmMemPoolTable.jvmMemPoolCollectThreshold.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolCollectThreshold.description=The threshold value for the collection usage of this memory pool, in bytes. A zero value (0) indicates that no threshold value is configured. When the amount of used memory crosses over this threshold value the JVM will trigger a collection memory threshold exceeded notification, and the jvmMemPoolCollectThreshdCount increases. If collection usage threshold is not supported, then this object, if implemented, will always be equals to 0. In that case, attempting to set this object will trigger an inconsistentValue error. See also jvmMemPoolCollectThreshdSupport. See java.lang.management.MemoryPoolMXBean. getCollectionUsageThreshold(), java.lang.management.MemoryPoolMXBean. setCollectionUsageThreshold(long), java.lang.management.MemoryPoolMXBean. isCollectionUsageThresholdSupported(), java.lang.management.MemoryPoolMXBean. getCollectionUsageThresholdCount() 
report.jvmMemPoolTable.jvmMemPoolCollectThreshold.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectThreshold" \
 DEF:var={rrd1}:jvmMemPoolCollThres:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolCollectThreshold" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmMemPoolTable.jvmMemPoolCollectThreshdCount.name=JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectThreshdCount
report.jvmMemPoolTable.jvmMemPoolCollectThreshdCount.columns=jvmMemPooColThrCoun
report.jvmMemPoolTable.jvmMemPoolCollectThreshdCount.type=jvmMemPoolEntry
report.jvmMemPoolTable.jvmMemPoolCollectThreshdCount.description=The number of times that the memory usage has crossed the collection usage threshold, as detected by the Java virtual machine. If memory usage threshold is not supported, then this object, if implemented, will always be equals to 0. See also jvmMemPoolCollectThreshdSupport. See java.lang.management.MemoryPoolMXBean. getCollectionUsageThresholdCount(), java.lang.management.MemoryPoolMXBean. isCollectionUsageThresholdSupported() 
report.jvmMemPoolTable.jvmMemPoolCollectThreshdCount.command=--title="JVM-MANAGEMENT-MIB::jvmMemPoolTable::jvmMemPoolCollectThreshdCount" \
 DEF:var={rrd1}:jvmMemPooColThrCoun:AVERAGE \
 LINE1:var#00ccff:"jvmMemPoolCollectThreshdCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreading.jvmThreadCount.name=JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadCount
report.jvmThreading.jvmThreadCount.columns=jvmThreadCount
report.jvmThreading.jvmThreadCount.type=nodeSnmp
report.jvmThreading.jvmThreadCount.description=The current number of live threads. See java.lang.management.ThreadMXBean.getThreadCount() 
report.jvmThreading.jvmThreadCount.command=--title="JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadCount" \
 DEF:var={rrd1}:jvmThreadCount:AVERAGE \
 LINE1:var#00ccff:"jvmThreadCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreading.jvmThreadDaemonCount.name=JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadDaemonCount
report.jvmThreading.jvmThreadDaemonCount.columns=jvmThreaDaemonCount
report.jvmThreading.jvmThreadDaemonCount.type=nodeSnmp
report.jvmThreading.jvmThreadDaemonCount.description=The current number of daemon threads. See java.lang.management.ThreadMXBean.getDaemonThreadCount() 
report.jvmThreading.jvmThreadDaemonCount.command=--title="JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadDaemonCount" \
 DEF:var={rrd1}:jvmThreaDaemonCount:AVERAGE \
 LINE1:var#00ccff:"jvmThreadDaemonCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreading.jvmThreadPeakCount.name=JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadPeakCount
report.jvmThreading.jvmThreadPeakCount.columns=jvmThreadPeakCount
report.jvmThreading.jvmThreadPeakCount.type=nodeSnmp
report.jvmThreading.jvmThreadPeakCount.description=The peak thread count since the execution of the application. See java.lang.management.ThreadMXBean.getPeakThreadCount() 
report.jvmThreading.jvmThreadPeakCount.command=--title="JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadPeakCount" \
 DEF:var={rrd1}:jvmThreadPeakCount:AVERAGE \
 LINE1:var#00ccff:"jvmThreadPeakCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreading.jvmThreadTotalStartedCount.name=JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadTotalStartedCount
report.jvmThreading.jvmThreadTotalStartedCount.columns=jvmThreTotaStarCoun
report.jvmThreading.jvmThreadTotalStartedCount.type=nodeSnmp
report.jvmThreading.jvmThreadTotalStartedCount.description=The total number of threads created and started since the Java Virtual Machine started. See java.lang.management.ThreadMXBean.getTotalStartedThreadCount() 
report.jvmThreading.jvmThreadTotalStartedCount.command=--title="JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadTotalStartedCount" \
 DEF:var={rrd1}:jvmThreTotaStarCoun:AVERAGE \
 LINE1:var#00ccff:"jvmThreadTotalStartedCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreading.jvmThreadPeakCountReset.name=JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadPeakCountReset
report.jvmThreading.jvmThreadPeakCountReset.columns=jvmThrePeakCounRese
report.jvmThreading.jvmThreadPeakCountReset.type=nodeSnmp
report.jvmThreading.jvmThreadPeakCountReset.description= This object indicates the last time - in milliseconds - at which the peak thread count was reset to the current thread count. This corresponds to a time stamp as returned by java.lang.System.currentTimeMillis(). Setting this object to a time earlier than its current time value has no effect. Setting this object to a time later than its current time value causes the peak thread count statistic to be reset to the current thread count. The new value of this object will be the time at which the reset operation is triggered. There could be a delay between the time at which the reset operation is triggered and the time at which the actual resetting happens, so this value is only indicative. See java.lang.management.ThreadMXBean.resetPeakThreadCount() 
report.jvmThreading.jvmThreadPeakCountReset.command=--title="JVM-MANAGEMENT-MIB::jvmThreading::jvmThreadPeakCountReset" \
 DEF:var={rrd1}:jvmThrePeakCounRese:AVERAGE \
 LINE1:var#00ccff:"jvmThreadPeakCountReset" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreadInstanceTable.jvmThreadInstId.name=JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstId
report.jvmThreadInstanceTable.jvmThreadInstId.columns=jvmThreadInstId
report.jvmThreadInstanceTable.jvmThreadInstId.type=jvmThreadInstanceEntry
report.jvmThreadInstanceTable.jvmThreadInstId.description=The thread ID, as returned by Thread.getId(). See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean). getThreadId() 
report.jvmThreadInstanceTable.jvmThreadInstId.command=--title="JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstId" \
 DEF:var={rrd1}:jvmThreadInstId:AVERAGE \
 LINE1:var#00ccff:"jvmThreadInstId" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreadInstanceTable.jvmThreadInstBlockCount.name=JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstBlockCount
report.jvmThreadInstanceTable.jvmThreadInstBlockCount.columns=jvmThreInstBlocCoun
report.jvmThreadInstanceTable.jvmThreadInstBlockCount.type=jvmThreadInstanceEntry
report.jvmThreadInstanceTable.jvmThreadInstBlockCount.description=The total number of times that this thread has blocked to enter or re-enter a monitor.. See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean). getBlockedCount() 
report.jvmThreadInstanceTable.jvmThreadInstBlockCount.command=--title="JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstBlockCount" \
 DEF:var={rrd1}:jvmThreInstBlocCoun:AVERAGE \
 LINE1:var#00ccff:"jvmThreadInstBlockCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreadInstanceTable.jvmThreadInstBlockTimeMs.name=JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstBlockTimeMs
report.jvmThreadInstanceTable.jvmThreadInstBlockTimeMs.columns=jvmThrInsBlocTimeMs
report.jvmThreadInstanceTable.jvmThreadInstBlockTimeMs.type=jvmThreadInstanceEntry
report.jvmThreadInstanceTable.jvmThreadInstBlockTimeMs.description=The approximate accumulated elapsed time (in millisecond) that a thread has blocked to enter or re-enter a monitor since it has started - or since thread contention monitoring was enabled. This object is always set to 0 if thread contention monitoring is disabled or not supported. See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean). getBlockedTime() 
report.jvmThreadInstanceTable.jvmThreadInstBlockTimeMs.command=--title="JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstBlockTimeMs" \
 DEF:var={rrd1}:jvmThrInsBlocTimeMs:AVERAGE \
 LINE1:var#00ccff:"jvmThreadInstBlockTimeMs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreadInstanceTable.jvmThreadInstWaitCount.name=JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstWaitCount
report.jvmThreadInstanceTable.jvmThreadInstWaitCount.columns=jvmThreInstWaitCoun
report.jvmThreadInstanceTable.jvmThreadInstWaitCount.type=jvmThreadInstanceEntry
report.jvmThreadInstanceTable.jvmThreadInstWaitCount.description=The total number of times that this thread has waited for notification. See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean). getWaitedCount() 
report.jvmThreadInstanceTable.jvmThreadInstWaitCount.command=--title="JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstWaitCount" \
 DEF:var={rrd1}:jvmThreInstWaitCoun:AVERAGE \
 LINE1:var#00ccff:"jvmThreadInstWaitCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreadInstanceTable.jvmThreadInstWaitTimeMs.name=JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstWaitTimeMs
report.jvmThreadInstanceTable.jvmThreadInstWaitTimeMs.columns=jvmThrInsWaitTimeMs
report.jvmThreadInstanceTable.jvmThreadInstWaitTimeMs.type=jvmThreadInstanceEntry
report.jvmThreadInstanceTable.jvmThreadInstWaitTimeMs.description=The approximate accumulated elapsed time (in millisecond) that a thread has waited on a monitor through a java.lang.Object.wait method since it has started - or since thread contention monitoring wasenabled. This object is always set to 0 if thread contention monitoring is disabled or not supported. See java.lang.management.ThreadMXBean.getThreadInfo(long,boolean). getWaitedTime() 
report.jvmThreadInstanceTable.jvmThreadInstWaitTimeMs.command=--title="JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstWaitTimeMs" \
 DEF:var={rrd1}:jvmThrInsWaitTimeMs:AVERAGE \
 LINE1:var#00ccff:"jvmThreadInstWaitTimeMs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmThreadInstanceTable.jvmThreadInstCpuTimeNs.name=JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstCpuTimeNs
report.jvmThreadInstanceTable.jvmThreadInstCpuTimeNs.columns=jvmThrInstCpuTimeNs
report.jvmThreadInstanceTable.jvmThreadInstCpuTimeNs.type=jvmThreadInstanceEntry
report.jvmThreadInstanceTable.jvmThreadInstCpuTimeNs.description=The approximate accumulated CPU time (in nanosecond) for a thread since it has started - or since thread CPU time monitoring was enabled. If the thread of the specified ID is not alive or does not exist, or the CPU time measurement is disabled or not supported, this object is set to 0. See java.lang.management.ThreadMXBean.getThreadCpuTime(long), java.lang.management.ThreadMXBean.isThreadCpuTimeSupported(), java.lang.management.ThreadMXBean.isThreadCpuTimeEnabled() 
report.jvmThreadInstanceTable.jvmThreadInstCpuTimeNs.command=--title="JVM-MANAGEMENT-MIB::jvmThreadInstanceTable::jvmThreadInstCpuTimeNs" \
 DEF:var={rrd1}:jvmThrInstCpuTimeNs:AVERAGE \
 LINE1:var#00ccff:"jvmThreadInstCpuTimeNs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmRuntime.jvmRTInputArgsCount.name=JVM-MANAGEMENT-MIB::jvmRuntime::jvmRTInputArgsCount
report.jvmRuntime.jvmRTInputArgsCount.columns=jvmRTInputArgsCount
report.jvmRuntime.jvmRTInputArgsCount.type=nodeSnmp
report.jvmRuntime.jvmRTInputArgsCount.description=The number of input arguments passed to the Java Virtual Machine. See java.lang.management.RuntimeMXBean.getInputArguments() 
report.jvmRuntime.jvmRTInputArgsCount.command=--title="JVM-MANAGEMENT-MIB::jvmRuntime::jvmRTInputArgsCount" \
 DEF:var={rrd1}:jvmRTInputArgsCount:AVERAGE \
 LINE1:var#00ccff:"jvmRTInputArgsCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmRuntime.jvmRTUptimeMs.name=JVM-MANAGEMENT-MIB::jvmRuntime::jvmRTUptimeMs
report.jvmRuntime.jvmRTUptimeMs.columns=jvmRTUptimeMs
report.jvmRuntime.jvmRTUptimeMs.type=nodeSnmp
report.jvmRuntime.jvmRTUptimeMs.description=Uptime of the Java virtual machine, in milliseconds. This is equivalent to ( System.currentTimeMillis() - jvmStartTimeMs ). See also jvmRTStartTimeMs. See java.lang.management.RuntimeMXBean.getUptime() 
report.jvmRuntime.jvmRTUptimeMs.command=--title="JVM-MANAGEMENT-MIB::jvmRuntime::jvmRTUptimeMs" \
 DEF:var={rrd1}:jvmRTUptimeMs:AVERAGE \
 LINE1:var#00ccff:"jvmRTUptimeMs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmRuntime.jvmRTStartTimeMs.name=JVM-MANAGEMENT-MIB::jvmRuntime::jvmRTStartTimeMs
report.jvmRuntime.jvmRTStartTimeMs.columns=jvmRTStartTimeMs
report.jvmRuntime.jvmRTStartTimeMs.type=nodeSnmp
report.jvmRuntime.jvmRTStartTimeMs.description=The approximate time when the Java virtual machine started, in milliseconds. This is a time stamp as returned by System.currentTimeMillis(). This time will not change unless the Java Virtual Machine is restarted. See also jvmRTUptimeMs. See java.lang.management.RuntimeMXBean.getStartTime() 
report.jvmRuntime.jvmRTStartTimeMs.command=--title="JVM-MANAGEMENT-MIB::jvmRuntime::jvmRTStartTimeMs" \
 DEF:var={rrd1}:jvmRTStartTimeMs:AVERAGE \
 LINE1:var#00ccff:"jvmRTStartTimeMs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmCompilation.jvmJITCompilerTimeMs.name=JVM-MANAGEMENT-MIB::jvmCompilation::jvmJITCompilerTimeMs
report.jvmCompilation.jvmJITCompilerTimeMs.columns=jvmJITCompileTimeMs
report.jvmCompilation.jvmJITCompilerTimeMs.type=nodeSnmp
report.jvmCompilation.jvmJITCompilerTimeMs.description=Gets the approximate accumulated elapsed time (in milliseconds) spent in compilation since the Java virtual machine has started. If multiple threads are used for compilation, this value is the summation of the approximate time that each thread spent in compilation. If compiler time monitoring is not supported, then this object remains set to 0. See java.lang.management.CompilationMXBean.getTotalCompilationTime() 
report.jvmCompilation.jvmJITCompilerTimeMs.command=--title="JVM-MANAGEMENT-MIB::jvmCompilation::jvmJITCompilerTimeMs" \
 DEF:var={rrd1}:jvmJITCompileTimeMs:AVERAGE \
 LINE1:var#00ccff:"jvmJITCompilerTimeMs" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

report.jvmOS.jvmOSProcessorCount.name=JVM-MANAGEMENT-MIB::jvmOS::jvmOSProcessorCount
report.jvmOS.jvmOSProcessorCount.columns=jvmOSProcessorCount
report.jvmOS.jvmOSProcessorCount.type=nodeSnmp
report.jvmOS.jvmOSProcessorCount.description=The number of processors available to the Java virtual machine. See java.lang.management.OperatingSystemMXBean.getAvailableProcessors() 
report.jvmOS.jvmOSProcessorCount.command=--title="JVM-MANAGEMENT-MIB::jvmOS::jvmOSProcessorCount" \
 DEF:var={rrd1}:jvmOSProcessorCount:AVERAGE \
 LINE1:var#00ccff:"jvmOSProcessorCount" \
 GPRINT:var:AVERAGE:"Avg\\: %8.2lf %s" \
 GPRINT:var:MIN:"Min\\: %8.2lf %s" \
 GPRINT:var:MAX:"Max\\: %8.2lf %s\\n"

